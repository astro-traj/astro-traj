#!/usr/bin/env python

# ---- Import standard modules to the python path.
import argparse

import os

import numpy as np

import astropy.units as u
import astropy.constants as C

from scipy.integrate import ode
from scipy.stats import maxwell
from scipy.stats import rv_continuous
from scipy.integrate import quad

from matplotlib import use
use('agg')
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

import pandas as pd

import h5py

from astro_traj import __version__
from astro_traj.system import System
from astro_traj.galaxy import Hernquist_NFW
from astro_traj import constr_dict
from astro_traj.sample import Sample
from astro_traj.plot import Plot


def parse_commandline():
    """Parse the arguments given on the command-line.
    """
    parser = argparse.ArgumentParser(description="""
    Main function. Samples parameters, implements kicks, and sees whether the systems is a 'successful' merger
    by merging at the proper projected distance.

    Writes to csv file in following format:
    [M2, Mns, Mhe, Apre, Apost, epre, epost, R, galcosth, galphi, Vkick, Tmerge, Rmerge, Rmerge_proj, Vfinal, flag]

    Flag description:
    0: Binary doesn't merge at the proper projected distance
    1: Binary mergers at the correct projected distance
    2: Binary's inspiral time is greater than 10 Gyr, does not evolve
    3: Binary is disrupted by SN kick
    4: Energy conservation requirement not met!!!
    """)
    parser.add_argument('-V', '--version', action='version', version=__version__)
    parser.add_argument('-o', '--offset', type=float, help="Offset from center of galaxy of event", required=True)
    parser.add_argument('-r', '--effective-radius', type=float, help="Effective radius", required=True)
    parser.add_argument('-s', '--samples', help="Path to posterior samples", required=True)
    parser.add_argument('-g', '--galaxy', type=str, default='NGC', help="Name of galaxy that is pulled from the dictionaries in constr_dict.py. Default=NGC")
    parser.add_argument('-t', '--telescope', type=str, default='ESO', help="Name of telescope that is pulled from the dictionaries in constr_dict.py. Default=ESO")
    parser.add_argument('-T', '--trials', type=int, default=1, help="Specify the number of trials. Default=1")
    parser.add_argument('-f', '--outfile', type=str, default='output', help="Name of the output file. Default=output")

    parser.add_argument('--Apre', type=str, default='uniform', help="Specify sampling procedure for initial semi-major axis. Default=uniform")
    parser.add_argument('--Mhe', type=str, default='uniform', help="Specify sampling procedure for helium star mass. Default=uniform")
    parser.add_argument('--Vkick', type=str, default='maxwellian', help="Specify sampling procedure for kick velocity. Default=maxwellian")
    parser.add_argument('--Ms', type=str, default='posterior', help="Specify sampling procedure for NS masses. Default=posterior")
    parser.add_argument('--epre', type=str, default='circularized', help="Specify sampling procedure for initial eccentricity. Default=circularized")
    parser.add_argument('--distance', type=str, default='delta_function', help="Specify sampling procedure for the distance. Default=delta_function")
    args = parser.parse_args()

    return args

def main(samples, galaxy_name, offset, r_eff, telescope):
    """
    Main function. Samples parameters, implements kicks, and sees whether the systems is a 'successful' merger
    by merging at the proper projected distance.

    Writes to csv file in following format:
    [M2, Mns, Mhe, Apre, Apost, epre, epost, R, galcosth, galphi, Vkick, Tmerge, Rmerge, Rmerge_proj, Vfinal, flag]

    Flag description:
    0: Binary doesn't merge at the proper projected distance
    1: Binary mergers at the correct projected distance
    2: Binary's inspiral time is greater than 10 Gyr, does not evolve
    3: Binary is disrupted by SN kick
    4: Energy conservation requirement not met!!!
    """

    print "\nInitializing galaxy and reading inputs..."
    # set cosmology to Reiss [h = H0/(100 km/s/Mpc)]
    h = 0.73
    # Info from "GW"
    GW = constr_dict.GW(samples)
    # Info about the galaxy
    Galaxy = constr_dict.galaxy(galaxy_name, samples, r_eff, offset, h)
    # Infer about the telescope that made the measurements (for angular resolution)
    tele = constr_dict.telescope(telescope)

    # Initialize potential with galactic parameters, choose from one of the definied potentials in galaxy class
    gal=Hernquist_NFW(Galaxy['Mspiral'], Galaxy['Mbulge'], Galaxy['Mhalo'], Galaxy['R_eff'], h, rcut=100)
    samp=Sample(gal)
    # Initialize R
    PDF = samp.initialize_R()


    # Create empty output file
    df = pd.DataFrame([], columns=['M2', 'Mns', 'Mhe', 'Apre', 'Apost', 'epre', 'epost', 'd', 'R', 'galcosth', 'galphi', 'Vkick', 'Tmerge', 'Rmerge', 'Rmerge_proj', 'Vfinal', 'flag'])
    df.to_csv(args.outfile+'.dat', sep=',', index=False)



    #########################
    ####### MAIN LOOP #######
    #########################
    Nsys=args.trials
    dEfrac = 0.0

    # Initialize random draws for some parameters based on number of trials
    print "\nSampling binary parameters..."
    
    Mcomp_dist, Mns_dist = samp.sample_masses(samples, method=args.Ms, size=Nsys)
    # (Msun)

    d_dist = samp.sample_distance(samples, method=args.distance, size=Nsys)
    # (Mpc)

    Mhe_dist = samp.sample_Mhe(Mmin=Mns_dist, method=args.Mhe, size=Nsys)
    # (Msun)

    Apre_dist = samp.sample_Apre(Amin=0.1, Amax=10.0, method=args.Apre, size=Nsys)
    # (Rsun)

    epre_dist = samp.sample_epre(method=args.epre, size=Nsys)
    # (dimensionless)

    Vkick_dist = samp.sample_Vkick(method=args.Vkick, size=Nsys)
    # (km/s)

    R_dist = samp.sample_R(PDF, Nsys)
    # (kpc)


    print "\nStarting the evolution of sampled binaries!"
    for R, d, Mcomp, Mns, Apre, epre, Mhe, Vkick in zip(R_dist, d_dist, Mcomp_dist, Mns_dist, Apre_dist, epre_dist, Mhe_dist, Vkick_dist):
    
        # Calculate angular resolution of the telescope, convert to physical size at the distance of merger
        theta = 1.22 * 1e-9 * tele['lambda'] / tele['D']
        D_theta = d*np.tan(theta)                # units of Mpc
        Galaxy['offset_uncer'] = D_theta*u.Mpc.to(u.kpc)   # offset uncertainty from angular resolution of telescope (kpc)

        # initialize System class with pertinent parameters
        T=System(gal, R, Mns, Mcomp, Mhe, Apre, epre, d, Vkick)
        # implement a SN kick to the system, and check to see if binary is disrupted
        T.SN()
        # if binary is disrupted, move on to next system
        if T.flag == 3:
            continue

        # set merger time for trajectory integration, specify Tmin and Tmax in Gyr
        T.setTmerge(Tmin=0.0, Tmax=10.0)
        # if binary does not meet inspiral time requirements, move on to next system
        if T.flag == 2:
            outdata = T.write_data()
            f = open(args.outfile+'.dat', 'a')
            f.write(str(outdata)[1:-1]+'\n')
            f.close()
            continue

        # choose random location on sphere of radius R
        T.setXYZ_0()
        # choose random direction for circular velocity, and add SN-imparted velocity to get V0
        T.setVxyz_0()

        # integrate trajectory until Tmerge
        T.doMotion()

        # now, see if a successful binary for replicating GW has been created!
        T.check_success(Galaxy['offset'], uncer=Galaxy['offset_uncer'])

        # check for energy conservation, and hold onto highest offset
        T.energy_check()
        if T.dEfrac > dEfrac:
            dEfrac = T.dEfrac


        # hold onto output data if successful binary is produced
        outdata = T.write_data()
        f = open(args.outfile+'.dat', 'a')
        f.write(str(outdata)[1:-1]+'\n')
        f.close()



    ########################
    ####### END LOOP #######
    ########################


    # print maximum energy difference to check for conservation of energy
    print '\nFinished! Maximum energy difference between initial post-SN energy and final energy: %.20f' % dEfrac

if __name__ == '__main__':
    args = parse_commandline()
    main(args.samples, args.galaxy, args.offset, args.effective_radius, args.telescope)
